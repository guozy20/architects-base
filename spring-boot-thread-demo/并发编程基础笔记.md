

简单来说，并发是指单位时间内能够同时处理的请求数。默认情况下Tomcat可以支持的最大请求数是

150，也就是同时支持150个并发。当超过这个并发数的时候，就会开始导致响应延迟，连接丢失等问

题。

# 影响服务器吞吐量的因素

## 硬件

CPU、内存、磁盘、网络

## 软件层面

最大化的利用硬件资源

线程数量、JVM内存分配大小、网络通信机制（BIO、NIO、AIO）、磁盘IO

## 线程数量如何提升服务端的并发数量

# 并发和并行

并行是指两个或者多个事件在同一时刻发生；

并发是指两个或多个事件在同一时间间隔内发生，这个词可以冲宏观和微观两个层面来讲，如果从微观

角度来看。以线程为例，假设当前电脑的cpu是单核，但是能不能支持多线程呢？当然也是能的，此时

如果是多线程运行的话，那么CPU是通过不断分配时间片的方式来实现线程切换，由于切换的速度足够

快，我们很难感知到卡顿的过程。

# Java中的线程

* Runnable 接口

* Thread 类

- Callable/Future 带返回值的

# Thread这个工具在哪些场景可以应用

- 网络请求分发的场景

- 文件导入

- 短信发送场景



# 线程的基础

## 线程的生命周期

线程的启动->结束

> 阻塞

WAITING

TIME_WAITING

BLOCKED

IO阻塞

## Java的线程有多少种状态：6种

new Thread(); 状态：NEW，这个是在Java中才有的状态

![image-20200903211343154](C:\Users\guozy\AppData\Roaming\Typora\typora-user-images\image-20200903211343154.png)



需要注意的是，操作系统中的线程除去 new 和 terminated 状态，一个线程真实存在的状态，只有：

- ready ：表示线程已经被创建，正在等待系统调度分配CPU使用权。

- running ：表示线程获得了CPU使用权，正在进行运算

- waiting ：表示线程等待（或者说挂起），让出CPU资源给其他线程使用

在加上新建状态和死亡状态，一共5种

## 线程的启动

new Thread().start(); //启动一个线程

Thread t1=new Thread()

t1.run(); //调用实例方法

![image-20200903211517205](C:\Users\guozy\AppData\Roaming\Typora\typora-user-images\image-20200903211517205.png)



## 线程的终止

> 线程什么情况下会终止

run方法执行结束

volatile jint _interrupted; // Thread.isInterrupted state

```cpp
void os::interrupt(Thread* thread) {
 assert(Thread::current() == thread || Threads_lock->owned_by_self(), 
        "possibility of dangling Thread pointer"); 
    
 OSThread* osthread = thread->osthread(); 
    
 if (!osthread->interrupted()) {
	osthread->set_interrupted(true); //设置一个中断状态 
	// More than one thread can get here with the same value of osthread, 
	// resulting in multiple notifications. We do, however, want the store 
	// to interrupted() to be visible to other threads before we execute unpark(). 
     
	OrderAccess::fence(); 
	ParkEvent * const slp = thread->_SleepEvent ; //如果是sleep中，唤醒 
	if (slp != NULL) slp->unpark() ; 
}
    
// For JSR166. Unpark even if interrupt status already was set 
if (thread->is_Java_thread()) 
	((JavaThread*)thread)->parker()->unpark(); 
    
	ParkEvent * ev = thread->_ParkEvent ; 
	if (ev != NULL) ev->unpark() ; 
}
```



## interrupt()的作用

设置一个共享变量的值 true

唤醒处于阻塞状态下的线程。

# 一个问题引发的问题

```java
public class App {

    public static int count = 0;

    public static void incr() {
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (App.class) {
            count++;
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            new Thread(() -> App.incr()).start();
        }
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("运行结果：" + count);
    }
}
```

结果是小于等于1000的随机数。

原因： 可见性、原子性

# count++的指令

javap -v App.class 查看class文件的字节码

```
17: getstatic     #6                  // Field count:I
20: iconst_1
21: iadd
22: putstatic     #6                  // Field count:I
```

* getstatic 是一个指令，访问一个静态的变量
* iconst_1 去压入到栈中
* iadd 去递增
* putstatic 设置一个静态变量

# 锁（Synchronized）

互斥锁的本质是什么?

> 共享资源

## 锁的使用

可以修饰在方法层面和代码块层面

```java
class Test { // 修饰非静态方法
    Object obj = new Object();

    synchronized void demo() {
        // 临界区 
    }// 修饰代码块 

    void demo01() {
        synchronized (obj) {
            // 临界区 
        }
    }
}
```

## 锁的作用范围

synchronized有三种方式来加锁，不同的修饰类型，代表所的控制粒度：

1. 修饰实例方法，作用于当前实例加锁，计入同步代码块前要获得当前实例的锁。
2. 静态方法，作用于当前类对象加锁，进入同步代码块前要获得当前类的锁。
3. 修改代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。

# 锁的存储（对象头）

```java
// 32 bits: 
// -------- 
// hash:25 ------------>| age:4 biased_lock:1 lock:2 (normal object) 
// JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased object) 
// size:32 ------------------------------------------>| (CMS free block) 
// PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object) 
//// 64 bits: 
// -------- 
// unused:25 hash:31 -->| unused:1 age:4 biased_lock:1 lock:2 (normal object) 
// JavaThread*:54 epoch:2 unused:1 age:4 biased_lock:1 lock:2 (biased object) 
// PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object) 
// size:64 ----------------------------------------------------->| (CMS free block)
```

![image-20200904094052448](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200904094052448.png)



![image-20200904094128686](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200904094128686.png)



## 打印类的布局

```xml
<dependency>
    <groupId>org.openjdk.jol</groupId>
    <artifactId>jol-core</artifactId>
    <version>0.10</version>
</dependency>
```

代码：

```java
public class ClasslayOutDemo {
    public static void main(String[] args) {
        ClasslayOutDemo classlayOutDemo = new ClasslayOutDemo();
        System.out.println(ClassLayout.parseInstance(classlayOutDemo).toPrintable());
    }
}
```

输出结果：

96位->压缩以后的（object header）12字节*8bit

> com.guozy.thread.example.ClasslayOutDemo object internals:
>  OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
>       0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
>       4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
>       8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)
>      12     4        (loss due to the next object alignment)
> Instance size: 16 bytes
> Space losses: 0 bytes internal + 4 bytes external = 4 bytes **total

大端存储和小端存储

>       0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
>       4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)

0x(16进制)： 00 00 00 00 00 00 00 01

64位二进制： 00000000 00000000 00000000 00000000 00000000 00000000 00000000  00000001

通过最后三位来看锁的状态和标记。  根据二进制码结合上图，可以看出最后三位是001，为无锁态。

## 通过打印加锁类来查看对象头 

修改代码，把对象加上锁后看类的布局

```java
public class ClasslayOutDemo {
    public static void main(String[] args) {
        ClasslayOutDemo classlayOutDemo = new ClasslayOutDemo();
        synchronized (classlayOutDemo) {
            System.out.println("locking");
            System.out.println(ClassLayout.parseInstance(classlayOutDemo).toPrintable());
        }
    }
}
```

输出结果：

> com.guozy.thread.example.ClasslayOutDemo object internals:
>  OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
>       0     4        (object header)                           28 f5 56 03 (00101000 11110101 01010110 00000011) (56030504)
>       4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
>       8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)
>      12     4        (loss due to the next object alignment)
> Instance size: 16 bytes
> Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

从输出结果可以看出是轻量级锁，最后三位为000标识轻量级锁

# 锁的升级

![未命名文件](C:\Users\Administrator\Downloads\未命名文件.jpg)

## 偏向锁

​	在大多数情况下，锁不仅仅不存在多线程的竞争，而且总是由同一个线程多次获得。在这个背景下就设计了偏向锁。偏向锁，顾名思义，就是偏向于某个线程。

​	当一个线程访问不了同步锁代码块时，会在对象头中存储当前线程的ID，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁，而是直接比较对象头里面是否存储了指向当前线程的偏向锁。如果相等表示偏向锁的偏向于当前线程的，就不需要再尝试获得锁了，引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。（偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。）

JDK1.6之后引入了偏向锁的概念，偏向锁是一种乐观锁(假设所有线程访问共享资源时不会出现冲突)。

偏向锁是默认开启的，而且开始时间一般是比应用程序启动慢几秒，如果不想有这个延迟，那么可以使用-XX:BiasedLockingStartUpDelay=0；
如果不想要偏向锁，那么可以通过-XX:-UseBiasedLocking = false来设置；

> 打开偏向锁
>
> -XX:+UseBiasedLocking -XX:BiaseLockingStartupDelay=0

```txt
com.guozy.thread.example.ClasslayOutDemo object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           05 28 3e 03 (00000101 00101000 00111110 00000011) (54405125)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
```

00000000 00000000 00000000 00000000  00000011  00111110  00101000  00000101 

后三位为101，表示偏向锁

### 1.偏向锁的获取

- 1.因为锁标志位为01的时候会存储线程ID，当一个线程进入同步代码块的时候判断对象头里的Mark Word是否存储着指向当前线程ID，如果有就让当前线程获得锁。（这里可以解释，当同一个线程不断重入偏向锁的时候不需要进行CAS操作，只需要进行一个判断就可以获得锁）最后执行步骤5。如果没有，则进行步骤2的判断。
- 2.判断Mark Word中偏向锁标识是否设置为1(表示当前是偏向锁), 如果是的话指向步骤3 ,否则执行步骤4
- 3.尝试使用CAS将对象头的偏向锁指向当前线程, 成功表示获取偏向锁成功, 则执行步骤5, 失败则表示存在竞争, 偏向锁要升级为轻量级锁, 偏向锁撤销和升级的流程下面再进行说明
- 4.此时表示需要CAS竞争锁。
- 5.执行同步代码块

### 2.偏向锁的撤销或者升级

- 偏向锁可以膨胀升级为轻量级锁，前提是有第二个线程试图获取此偏向锁。
- 当两个线程试图获取同一个偏向锁的时候，如下图所示：

![img](https://img-blog.csdnimg.cn/20181119222831471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDg3MDMz,size_16,color_FFFFFF,t_70)

- 在线程1执行同步代码块之前的步骤上面已经解释了，下面从线程2尝试获取锁开始：
- 1.判断Mark Word中是否有指向自己的线程ID，否。
- 2.判断当前锁是否为偏向锁，是。那么线程2会用CAS替换来尝试获取锁。 CAS替换Mark Word成功表示获取偏向锁成功, 这里由于对象头中Mark Word已经指向了线程1, 所以替换失败, 需要进行撤销操作。
- 3.撤销偏向锁, 需要等待全局安全点(safepoint)，就是当前时间点上没有字节码正在执行。
- 4.撤销的时候需要等线程1全部跑完run方法，然后暂停线程1，如果线程1已经终止了，则将锁对象的对象头设置为无锁状态(方便下一个线程进来)。如果对象1还未终止，恢复线程1，并将锁升级为轻量级锁，然后和线程2一起CAS竞争轻量级锁。
- 我个人认为，拥有偏向锁的线程不会自动释放锁，第一个线程申请偏向锁的时候会成功，第二个线程来申请偏向锁的时候，不管第一个线程执行完毕还是未完毕，都要进行一次撤销或者升级的操作，因为当时Mark Wrod中保存的指针不是线程2，所以只有撤销为无锁状态，线程2才能成为新的偏向锁偏向的线程
- 锁的对象头中偏向着线程1，因为它不知道线程1什么时候来，所以一直偏向着，就算线程1已经死亡了。所以撤销锁的时候，先检查对象头所指向的线程是否存活，如果不存活，那么偏向锁撤销为无锁，如果存在，那么线程1目前没有拿着锁而在干别的事情，这样锁就在不同时间段被不同线程访问了升级为轻量级锁，线程2就拿到了锁。

## 轻量级锁 

如果偏向锁被关闭或者当前偏向锁已经已经被其他线程获取，那么这个时候如果有线程去抢占同步锁
时，锁会升级到轻量级锁。  